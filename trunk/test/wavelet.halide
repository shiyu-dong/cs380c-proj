#include "Halide.h"
h
#define RESULT_TYPE float
using namespace Halide;

const float D0 = 0.4829629131445341f;
const float D1 = 0.83651630373780772f;
const float D2 = 0.22414386804201339f;
const float D3 = -0.12940952255126034f;

int main(int argc, char **argv) {
  Func clamped(x, y);
  Func wavelet_clamped(x, y, c);
  Func inv_haar_x(x, y);
  Func for_haar_x(x, y);
  Func inv_daub_x(x, y);
  Func for_daub_x(x, y);
  Var x, y, c;

  Image image<float>(32, 2);
  Image wavelet<float>(32, 3);

  // Add a boundary condition for daubechies
  //clamped(x, y) = image(clamp(x, 0, image.width()-1), clamp(y, 0, image.height()-1));
  clamped(x, y) = image(clamp(x, 0, 31), clamp(y, 0, 31));

  //wavelet_clamped(x, y, c) = wavelet(clamp(x, 0, wavelet.width()-1),  clamp(y, 0, wavelet.height()-1), c);
  wavelet_clamped(x, y, c) = wavelet(clamp(x, 0, 31), clamp(y, 0, 31), c);

  inv_haar_(x, y) = select(x%2 == 0, wavelet_clamped(x/2, y, 0) + wavelet_clamped(x/2, y, 1),
      wavelet_clamped (x/2, y, 0) - wavelet_clamped(x/2, y, 1));

  haar_x(x, y) = (clamped(2*x, y) + clamped(2*x+1, y), clamped(2*x, y) - clamped(2*x+1, y))/2;

  inv_daub_x = select(x%2 == 0, D2*wavelet_clamped(x/2, y, 0) + D1*wavelet_clamped(x/2, y, 1) + D0*wavelet_clamped(x/2+1, y, 0) + D3*wavelet_clamped(x/2+1, y, 1), D3*wavelet_clamped(x/2, y, 0) - D0*wavelet_clamped(x/2, y, 1) + D1*wavelet_clamped(x/2+1, y, 0) - D2*wavelet_clamped(x/2+1, y, 1));

  for_daub_x(x, y) = (D0*clamped(2*x-1, y) + D1*clamped(2*x, y) + D2*clamped(2*x+1, y) + D3*clamped(2*x+2, y), D3*clamped(2*x-1, y) - D2*clamped(2*x, y) + D1*clamped(2*x+1, y) - D0*clamped(2*x+2, y));

  return 0;
}
